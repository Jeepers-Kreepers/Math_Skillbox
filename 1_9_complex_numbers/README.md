# Задание

$x = sp.Matrix([[2, 5, 0], [1, 3 - sp.I, 2 + sp.I]])$

$z = sp.Matrix([[5, sp.I, 0], [1, 14, -2 - 3 * sp.I]])$

Найти решение $x * y = z$ (найти матрицу $y$)



```python
import sympy as sp

x = sp.Matrix([[2, 5, 0], [1, 3 - sp.I, 2 + sp.I]])
z = sp.Matrix([[5, sp.I, 0], [1, 14, -2 - 3 * sp.I]])

# Проверяем размеры матриц, чтобы убедиться, что умножение x * y имеет смысл.
# x - матрица 2x3, z - матрица 2x3.
# Для x * y = z, y должна быть матрицей 3x3.
# Если y 3x3 - то решение возможно.
# Если y 3xk, то решений будет k столбцов.

try:
  y_sol = x.pinv() * z # Используем псевдообратную матрицу.  Если x не квадратная и обратимая, то x.inv() выдаст ошибку.
  print("Решение для y:")
  sp.pprint(y_sol)
except sp.LinAlgError:
  print("Невозможно найти решение: матрица x не обратима или не подходит по размеру.")
except ValueError as e:
  print(f"Ошибка: {e}")
```

python

**Объяснение:**

1. **Импорт sympy:**  `import sympy as sp` импортирует библиотеку SymPy.
2. **Определение матриц:**  `x` и `z` определены как матрицы SymPy.
3. **Проверка размеров:**  В коде проверяются размеры матриц `x`​ и `z`​ для определения размеров матрицы `y`​. Это позволяет понять, возможно ли найти решение. В данном случае, `x`​ имеет размер 2x3, и `z`​ имеет размер 2x3. Чтобы `x * y = z`​ имело смысл, `y`​ должна быть матрицей размера 3x3.
4. **Решение с помощью псевдообратной матрицы:**  Поскольку матрица `x`​ не квадратная, мы не можем просто использовать `x.inv()`​ (обратную матрицу). Вместо этого мы используем `x.pinv()`​, которая вычисляет псевдообратную матрицу Мура-Пенроуза. Псевдообратная матрица может быть использована для решения систем линейных уравнений, даже когда матрица не квадратная или имеет ранг, меньший, чем количество строк или столбцов. `y_sol = x.pinv() * z`​ решает уравнение `x * y = z`​ для `y`​.
5. **Обработка исключений:**  Код использует блок `try...except`​ для обработки возможных ошибок:

    * `sp.LinAlgError`: Обрабатывает случай, когда псевдообратная матрица не может быть вычислена.
    * `ValueError`: Обрабатывает ошибки, возникающие, если матрицы имеют неправильные размеры для умножения.
6. **Вывод решения:**  Если решение найдено, оно выводится с использованием `sp.pprint()`​.

**Как это работает:**

Псевдообратная матрица `x.pinv()` находит “наилучшее” решение для `y`​ в смысле минимизации ошибки `||x*y - z||`​. В общем случае, если система имеет больше уравнений, чем неизвестных, то псевдообратная матрица находит решение в смысле метода наименьших квадратов. Если система имеет больше неизвестных, чем уравнений, то псевдообратная матрица находит решение с минимальной нормой.

**Важно:**

* **Псевдообратная матрица:**  `x.pinv()` — ключ к решению в этом случае.
* **Размеры матриц:**  Убедитесь, что размеры матриц совместимы для умножения. Если `x`​ (m x n) и `z`​ (m x k), то `y`​ должна быть (n x k).
* **Интерпретация решения:**  Решение, полученное с использованием псевдообратной матрицы, может не быть единственным. Если у системы меньше уравнений, чем неизвестных (как в данном случае, где `x`​ имеет размер 2x3), то существует бесконечное множество решений. `y_sol`​ будет одним из таких решений.
* **Проверка:**  В большинстве случаев полезно проверить, что `x * y_sol`​ действительно близко к `z`​. Вы можете сделать это, используя `x * y_sol - z`​. Ожидается, что результат будет близким к нулевой матрице (с учетом погрешности вычислений).


